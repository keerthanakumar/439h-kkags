Keerthana Kumar
kk8
Andrew Sharp
ags799

Lab3

1. We have a trap handler for cases in which there is no error code pushed (in which case we push it ourselves), and we have another trap handler for cases in which there is an error code pushed.

2. We did not have to do anything to make the program behave correctly. int $14 produces an interrupt vector 13 because int $14 is privilege level 0. When user/softint tries to call int $14, it produces a general protection fault (interrupt vector 13), because the IDT says that int $14 is only accessible to the kernel (it's defined with a privilege level of 0). If the kernel allows softint to invoke interrupt vector 14, then the user would have access to all of memory, including the memory outside of its environment.

3. If the break point entry in the IDT was set with privilege level 0, int $3 will produce a general protection fault (as long as its being called by a user process, which is the case with breakpoint). However, if the break point entry in the IDT has privilege level 3, then a break point exception is generated. The user process is allowed to access int $3 in this case.

4. The point of these mechanisms is to user certain exceptions to the kernel. If a page fault exception occurs, the kernel must be able to handle it, which means dealing with system-wide memory. This is a necessary ability for the system to function. However, user programs must not have access to this ability. This is just one example of why certain interrupts must be limited to kernel usage.

CHALLENGE:
We did the challenge that adds 'continue' and single-stepping functionality to the JOS monitor.

We added mon_c and mon_si functions for 'c' and 'si' monitor commands, respectively. The mon_c function returns -1, which forces the monitor to exit and returns to execution of the user program. The mon_si function sets the trap flag of the struct Trapframe's EFLAGS, and then returns -1. By setting the trap flag, we cause the hardware to execute an 'int $1' after executing the next instruction of the user program. We modified our trap_dispatch function so that 'int $1' instructions are handled identically to 'int $3' instruction: they pause execution of the user program and start the JOS monitor.
